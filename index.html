<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cat & Fish Hunt</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Jersey+10&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: #e6f7ff;
        font-family: "Jersey 10", sans-serif;
        color: #1c1f2a;
      }

      .wrap {
        width: min(900px, 92vw);
        display: grid;
        gap: 16px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 12px;
      }

      h1 {
        font-size: clamp(1.4rem, 3vw, 2rem);
        margin: 0;
      }

      .hint {
        font-size: 1.1rem;
        color: #5a6275;
      }

      canvas {
        width: 100%;
        aspect-ratio: 16 / 9;
        background: linear-gradient(180deg, #c8f0ff 0%, #f7fbff 45%, #c5ecff 100%);
        border-radius: 22px;
        border: 2px solid #d4d9ef;
        box-shadow: 0 20px 40px -30px rgba(20, 24, 40, 0.5);
      }

      .stats {
        font-size: 1.4rem;
        color: #3f465a;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
      }

      .air {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 1.1rem;
        color: #2a4c63;
      }

      .air.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .air-bar {
        width: 160px;
        height: 14px;
        border-radius: 999px;
        border: 2px solid #2a6ea8;
        background: rgba(255, 255, 255, 0.8);
        overflow: hidden;
        box-shadow: inset 0 0 0 1px rgba(42, 110, 168, 0.15);
      }

      .air-fill {
        height: 100%;
        width: 100%;
        background: linear-gradient(90deg, #78e6ff 0%, #3fa9f5 100%);
        transition: width 120ms linear;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <h1>Cat & Fish Hunt</h1>
        <div class="hint">
          Use ← → to move. ↑ to jump. Shift to sprint. Level 2: ↑ ↓ to swim, surface for air.
        </div>
      </header>
      <canvas id="game" width="960" height="540"></canvas>
      <div class="stats">
        <span id="status">Fish: 0</span>
        <div class="air hidden" id="airHud">
          <span>Air</span>
          <div class="air-bar">
            <div class="air-fill" id="airFill"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const statusLabel = document.getElementById("status");
      const airHud = document.getElementById("airHud");
      const airFill = document.getElementById("airFill");

      const player = {
        x: canvas.width / 2,
        y: 0,
        radius: 18,
        speed: 420,
        sprintBoost: 1.6,
        color: "#ff7a59",
        vx: 0,
        vy: 0,
        jumpPower: 520,
      };

      const gravity = 1400;
      const waterGravity = 220;
      const swimAccel = 620;
      const waterDrag = 0.9;
      const waterSurfaceY = canvas.height * 0.32;
      const platform = {
        width: 180,
        height: 18,
      };
      const groundY = canvas.height - 70;
      const fallLimit = canvas.height + player.radius * 2;
      let isGameOver = false;
      let isWin = false;
      const keys = new Set();
      let lastTime = 0;
      let cameraY = 0;
      const platforms = [];
      let highestPlatformY = groundY;
      const snacks = [];
      const spoiledFish = [];
      let score = 0;
      let level = 1;
      let oxygen = 0;
      const maxOxygen = 10;
      const targetScoreLevel1 = 10;
      const targetScoreLevel2 = 14;
      let jumpQueued = false;
      let gameTime = 0;

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function randBetween(min, max) {
        return Math.random() * (max - min) + min;
      }

      function createPlatform(x, y, width = platform.width) {
        return { x, y, width, height: platform.height };
      }

      function seedPlatforms() {
        platforms.length = 0;
        snacks.length = 0;
        spoiledFish.length = 0;
        platforms.push(createPlatform(0, groundY, canvas.width));
        highestPlatformY = groundY;
        score = 0;
        isWin = false;
        oxygen = maxOxygen;
        updateScore();
        generatePlatforms();
      }

      function updateScore() {
        if (level === 2) {
          statusLabel.textContent = `Level 2 • Fish: ${score}`;
          airHud.classList.remove("hidden");
          const ratio = clamp(oxygen / maxOxygen, 0, 1);
          airFill.style.width = `${ratio * 100}%`;
          return;
        }
        statusLabel.textContent = `Level 1 • Fish: ${score}`;
        airHud.classList.add("hidden");
      }

      function endGame(message) {
        isGameOver = true;
        isWin = false;
        statusLabel.textContent = `${message} Score: ${score}. Press R to retry.`;
        stopBackgroundMusic();
        playLoserSound();
      }

      function endWin() {
        isGameOver = true;
        isWin = true;
        statusLabel.textContent = `Winner! Score: ${score}. Press R to retry.`;
        stopBackgroundMusic();
      }

      function createSnack(x, y) {
        return {
          x,
          y,
          baseX: x,
          baseY: y,
          radius: 9,
          collected: false,
          driftX: randBetween(30, 70),
          driftY: randBetween(8, 22),
          driftSpeed: randBetween(0.9, 1.6),
          phase: randBetween(0, Math.PI * 2),
        };
      }

      function createSpoiledFish(x, y) {
        return {
          x,
          y,
          baseX: x,
          baseY: y,
          radius: 10,
          active: true,
          driftX: randBetween(26, 60),
          driftY: randBetween(10, 26),
          driftSpeed: randBetween(1.0, 1.8),
          phase: randBetween(0, Math.PI * 2),
        };
      }

      function generatePlatforms() {
        const maxJumpHeight = (player.jumpPower * player.jumpPower) / (2 * gravity);
        const maxGap = Math.max(90, maxJumpHeight * 0.75);
        const minGap = 70;
        const maxAirTime = (2 * player.jumpPower) / gravity;
        const maxHoriz = player.speed * maxAirTime * 0.8;
        const minX = 24;
        const maxX = canvas.width - platform.width - 24;

        while (highestPlatformY > cameraY - 700) {
          const last = platforms[platforms.length - 1];
          const gap = randBetween(minGap, maxGap);
          const y = last.y - gap;
          const spreadX = randBetween(minX, maxX);
          let x = spreadX;
          const deltaX = x - last.x;
          if (Math.abs(deltaX) > maxHoriz) {
            x = last.x + Math.sign(deltaX) * maxHoriz * 0.9;
          }
          x = clamp(x, minX, maxX);
          platforms.push(createPlatform(x, y));
          if (Math.random() > 0.35) {
            snacks.push(createSnack(x + platform.width / 2, y - 16));
          }
          if (Math.random() > 0.85) {
            spoiledFish.push(createSpoiledFish(x + platform.width * 0.25, y - 16));
          }
          highestPlatformY = y;
        }
      }

      function seedUnderwaterLevel() {
        platforms.length = 0;
        snacks.length = 0;
        spoiledFish.length = 0;
        score = 0;
        oxygen = maxOxygen;
        isWin = false;
        cameraY = 0;
        const platformY = waterSurfaceY + 90;
        const secondY = waterSurfaceY + 170;
        platforms.push(createPlatform(40, platformY, 240));
        platforms.push(createPlatform(360, platformY + 20, 200));
        platforms.push(createPlatform(640, platformY - 10, 220));
        platforms.push(createPlatform(140, secondY, 200));
        platforms.push(createPlatform(460, secondY + 30, 220));

        for (let i = 0; i < 16; i += 1) {
          const x = randBetween(70, canvas.width - 70);
          const y = randBetween(waterSurfaceY + 150, canvas.height - 70);
          snacks.push(createSnack(x, y));
        }

        for (let i = 0; i < platforms.length; i += 2) {
          const plat = platforms[i];
          const hazardX = clamp(plat.x + plat.width * 0.5, 60, canvas.width - 60);
          const hazardY = Math.min(canvas.height - 60, plat.y + 50);
          spoiledFish.push(createSpoiledFish(hazardX, hazardY));
        }

        for (let i = 0; i < 2; i += 1) {
          const x = randBetween(60, canvas.width - 60);
          const y = randBetween(waterSurfaceY + 120, canvas.height - 80);
          spoiledFish.push(createSpoiledFish(x, y));
        }
        updateScore();
      }

      function handleKey(event, isDown) {
        const key = event.key;
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Shift"].includes(key)) {
          event.preventDefault();
        }
        if (isDown) {
          keys.add(key);
          if (key === "ArrowUp") {
            jumpQueued = true;
          }
        } else {
          keys.delete(key);
        }
      }

      window.addEventListener("keydown", (event) => handleKey(event, true));
      window.addEventListener("keyup", (event) => handleKey(event, false));

      function resetPlayer() {
        player.x = canvas.width / 2;
        player.y = level === 2 ? waterSurfaceY - player.radius - 4 : groundY - player.radius;
        player.vx = 0;
        player.vy = 0;
        isGameOver = false;
        statusLabel.textContent = "Fish: 0";
        cameraY = 0;
        if (level === 2) {
          seedUnderwaterLevel();
        } else {
          seedPlatforms();
        }
      }

      resetPlayer();

      function update(delta) {
        if (isGameOver) {
          return;
        }

        gameTime += delta;
        if (level === 2) {
          updateFishMotion(gameTime);
        }

        if (level === 1) {
          const sprint = keys.has("Shift") ? player.sprintBoost : 1;
          const velocity = player.speed * sprint;
          let dx = 0;
          let onGround = false;

          if (keys.has("ArrowLeft")) dx -= 1;
          if (keys.has("ArrowRight")) dx += 1;

          player.x += dx * velocity * delta;
          player.vy += gravity * delta;
          player.y += player.vy * delta;

          const prevY = player.y - player.vy * delta;

          for (const plat of platforms) {
            const withinX =
              player.x + player.radius > plat.x &&
              player.x - player.radius < plat.x + plat.width;
            const hitTop =
              player.vy >= 0 &&
              prevY + player.radius <= plat.y &&
              player.y + player.radius >= plat.y;
            if (withinX && hitTop) {
              player.y = plat.y - player.radius;
              player.vy = 0;
              onGround = true;
              break;
            }
          }

          if (onGround && jumpQueued) {
            player.vy = -player.jumpPower;
            jumpQueued = false;
            playJumpSound();
          }
        } else {
          let ax = 0;
          let ay = 0;

          if (keys.has("ArrowLeft")) ax -= 1;
          if (keys.has("ArrowRight")) ax += 1;
          if (keys.has("ArrowUp")) ay -= 1;
          if (keys.has("ArrowDown")) ay += 1;

          const surfaceBoost = keys.has("ArrowUp") ? 1.35 : 1;

          player.vx += ax * swimAccel * delta;
          player.vy += ay * swimAccel * delta * surfaceBoost;
          player.vy += waterGravity * delta;
          player.vx *= waterDrag;
          player.vy *= waterDrag;

          player.x += player.vx * delta;
          player.y += player.vy * delta;

          if (player.y > waterSurfaceY + player.radius) {
            oxygen = Math.max(0, oxygen - delta);
          } else {
            oxygen = Math.min(maxOxygen, oxygen + delta * 1.4);
          }
          updateScore();
          if (oxygen <= 0) {
            endGame("Status: Out of air!");
            return;
          }
        }

        for (const snack of snacks) {
          if (snack.collected) continue;
          const dist = Math.hypot(player.x - snack.x, player.y - snack.y);
          if (dist < player.radius + snack.radius) {
            snack.collected = true;
            score += 1;
            updateScore();
            playSnackSound();
            if (level === 1 && score >= targetScoreLevel1) {
              level = 2;
              resetPlayer();
              return;
            }
            if (level === 2 && score >= targetScoreLevel2) {
              endWin();
              break;
            }
          }
        }

        if (isGameOver) {
          return;
        }

        for (const bad of spoiledFish) {
          if (!bad.active) continue;
          const dist = Math.hypot(player.x - bad.x, player.y - bad.y);
          if (dist < player.radius + bad.radius) {
            bad.active = false;
            playSpoiledSound();
            endGame("Status: Spoiled fish!");
            break;
          }
        }


        if (level === 1) {
          player.x = clamp(player.x, player.radius, canvas.width - player.radius);
          player.y = clamp(player.y, -Infinity, fallLimit);

          cameraY = Math.min(cameraY, player.y - canvas.height * 0.6);
          generatePlatforms();

          while (
            platforms.length &&
            platforms[0].y - cameraY > canvas.height + 600
          ) {
            platforms.shift();
          }
          while (snacks.length && snacks[0].y - cameraY > canvas.height + 600) {
            snacks.shift();
          }
          while (
            spoiledFish.length &&
            spoiledFish[0].y - cameraY > canvas.height + 600
          ) {
            spoiledFish.shift();
          }

          if (player.y - cameraY > canvas.height + player.radius) {
            endGame("Status: Fell!");
          }
        } else {
          player.x = clamp(player.x, player.radius, canvas.width - player.radius);
          player.y = clamp(player.y, player.radius, canvas.height - player.radius);
        }
      }

      function updateFishMotion(time) {
        for (const snack of snacks) {
          if (snack.collected) continue;
          snack.x = snack.baseX + Math.sin(time * snack.driftSpeed + snack.phase) * snack.driftX;
          snack.y = snack.baseY + Math.cos(time * snack.driftSpeed + snack.phase) * snack.driftY;
        }
        for (const bad of spoiledFish) {
          if (!bad.active) continue;
          bad.x = bad.baseX + Math.cos(time * bad.driftSpeed + bad.phase) * bad.driftX;
          bad.y = bad.baseY + Math.sin(time * bad.driftSpeed + bad.phase) * bad.driftY;
        }
      }

      function draw(time) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (level === 2) {
          drawUnderwaterBackground();
        } else {
          drawBackground();
        }

        ctx.fillStyle = "#6b4b33";
        for (const plat of platforms) {
          const y = level === 2 ? plat.y : plat.y - cameraY;
          if (y > canvas.height || y + plat.height < -40) continue;
          drawRoundedRect(plat.x, y, plat.width, plat.height, 10);
          ctx.fill();
          drawGrassTop(plat.x, y, plat.width, plat.height);
        }

        ctx.fillStyle = "#58b7ff";
        for (const snack of snacks) {
          if (snack.collected) continue;
          const y = level === 2 ? snack.y : snack.y - cameraY;
          if (y > canvas.height || y + snack.radius < -40) continue;
          ctx.beginPath();
          ctx.ellipse(snack.x, y, snack.radius + 3, snack.radius, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(snack.x + snack.radius + 2, y);
          ctx.lineTo(snack.x + snack.radius + 10, y - 6);
          ctx.lineTo(snack.x + snack.radius + 10, y + 6);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = "#1c1f2a";
          ctx.beginPath();
          ctx.arc(snack.x - 4, y - 2, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#58b7ff";
        }

        ctx.fillStyle = "#7b5f86";
        for (const bad of spoiledFish) {
          if (!bad.active) continue;
          const y = level === 2 ? bad.y : bad.y - cameraY;
          if (y > canvas.height || y + bad.radius < -40) continue;
          ctx.beginPath();
          ctx.ellipse(bad.x, y, bad.radius + 4, bad.radius, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(bad.x + bad.radius + 2, y);
          ctx.lineTo(bad.x + bad.radius + 10, y - 6);
          ctx.lineTo(bad.x + bad.radius + 10, y + 6);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "#2b1f33";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(bad.x - 8, y - 3);
          ctx.lineTo(bad.x - 2, y + 3);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(bad.x - 8, y + 3);
          ctx.lineTo(bad.x - 2, y - 3);
          ctx.stroke();
          ctx.fillStyle = "#7b5f86";
        }

        drawCat(player.x, level === 2 ? player.y : player.y - cameraY, player.radius, time);

        if (isGameOver) {
          drawGameOver();
        }
      }

      function drawRoundedRect(x, y, width, height, radius) {
        const r = Math.min(radius, width / 2, height / 2);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      function drawBackground() {
        const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
        sky.addColorStop(0, "#c9e9ff");
        sky.addColorStop(0.45, "#e9f5ff");
        sky.addColorStop(1, "#fff2d7");
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
        drawCloud(110, 120, 120);
        drawCloud(320, 80, 150);
        drawCloud(660, 110, 170);
        drawCloud(840, 70, 130);

        ctx.fillStyle = "#cfe8b0";
        drawHills(0.55);
        ctx.fillStyle = "#b7da96";
        drawHills(0.68);

        const groundY = canvas.height * 0.78 - cameraY * 0.05;
        ctx.fillStyle = "#9ad17d";
        ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
        drawMeadow(groundY);
      }

      function drawUnderwaterBackground() {
        const sky = ctx.createLinearGradient(0, 0, 0, waterSurfaceY);
        sky.addColorStop(0, "#b6f1ff");
        sky.addColorStop(1, "#fff1c7");
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, canvas.width, waterSurfaceY);

        const sandHeight = 36;
        ctx.fillStyle = "#f4d08a";
        ctx.fillRect(0, waterSurfaceY - sandHeight, canvas.width, sandHeight);
        ctx.fillStyle = "#efc170";
        for (let i = 0; i < canvas.width; i += 70) {
          ctx.beginPath();
          ctx.ellipse(i + 20, waterSurfaceY - 12, 18, 6, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        drawPalm(canvas.width * 0.18, waterSurfaceY - sandHeight + 6);

        ctx.fillStyle = "rgba(255, 255, 255, 0.55)";
        ctx.fillRect(0, waterSurfaceY - 6, canvas.width, 8);

        const depth = ctx.createLinearGradient(0, waterSurfaceY, 0, canvas.height);
        depth.addColorStop(0, "#6bd1ff");
        depth.addColorStop(0.4, "#2c8ac7");
        depth.addColorStop(1, "#0f3f6e");
        ctx.fillStyle = depth;
        ctx.fillRect(0, waterSurfaceY, canvas.width, canvas.height - waterSurfaceY);

        ctx.fillStyle = "rgba(255, 255, 255, 0.18)";
        for (let i = 0; i < 18; i += 1) {
          const x = (i * 80 + performance.now() * 0.02) % (canvas.width + 80) - 40;
          const y = waterSurfaceY + (i * 60 + performance.now() * 0.04) % (canvas.height + 120) - 60;
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawPalm(x, y) {
        ctx.save();
        ctx.translate(x, y);

        ctx.strokeStyle = "#a46a2d";
        ctx.lineWidth = 10;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(20, -40, 12, -84);
        ctx.stroke();

        ctx.fillStyle = "#3fa85a";
        for (let i = 0; i < 5; i += 1) {
          ctx.save();
          ctx.translate(12, -84);
          ctx.rotate(-0.9 + i * 0.45);
          ctx.beginPath();
          ctx.ellipse(34, 0, 40, 12, 0.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        ctx.restore();
      }

      function drawCloud(x, y, size) {
        ctx.beginPath();
        ctx.ellipse(x, y, size * 0.6, size * 0.35, 0, 0, Math.PI * 2);
        ctx.ellipse(x + size * 0.4, y - size * 0.1, size * 0.5, size * 0.3, 0, 0, Math.PI * 2);
        ctx.ellipse(x - size * 0.4, y - size * 0.05, size * 0.45, size * 0.28, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawHills(heightRatio) {
        ctx.beginPath();
        const baseY = canvas.height * heightRatio - cameraY * 0.04;
        ctx.moveTo(0, baseY);
        for (let x = 0; x <= canvas.width; x += 80) {
          const bump = Math.sin((x + cameraY * 0.2) * 0.015) * 24;
          ctx.lineTo(x, baseY + bump);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.closePath();
        ctx.fill();
      }

      function drawMeadow(baseY) {
        ctx.fillStyle = "#7fcf6a";
        for (let i = 0; i < 18; i += 1) {
          const x = (i * 70 + cameraY * 0.3) % (canvas.width + 100) - 50;
          ctx.beginPath();
          ctx.ellipse(x, baseY + 18, 60, 16, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.fillStyle = "#ffffff";
        for (let i = 0; i < 20; i += 1) {
          const x = (i * 90 + cameraY * 0.5) % (canvas.width + 120) - 60;
          const y = baseY + 30 + (i % 4) * 22;
          ctx.beginPath();
          ctx.arc(x, y, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawGrassTop(x, y, width, height) {
        const grassHeight = Math.min(18, height * 0.9);
        ctx.fillStyle = "#7bd35a";
        drawRoundedRect(x - 2, y - grassHeight + 2, width + 4, grassHeight, 12);
        ctx.fill();
        ctx.fillStyle = "#6cbc4e";
        for (let i = 0; i < width; i += 18) {
          const bladeX = x + i + (i % 2 ? 6 : 0);
          ctx.beginPath();
          ctx.moveTo(bladeX, y - 4);
          ctx.lineTo(bladeX + 6, y - 12);
          ctx.lineTo(bladeX + 12, y - 4);
          ctx.closePath();
          ctx.fill();
        }

        ctx.fillStyle = "#7a5a3a";
        for (let i = 0; i < width; i += 26) {
          const stoneX = x + i + 8;
          ctx.beginPath();
          ctx.arc(stoneX, y + height * 0.55, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      let audioCtx = null;
      const bgMusic = new Audio("Fish Quest Feline.mp3");
      bgMusic.loop = true;
      bgMusic.volume = 0.5;
      const gameOverImage = new Image();
      gameOverImage.src = "ChatGPT Image Dec 23, 2025 at 12_34_59 AM.png";
      const winnerImage = new Image();
      winnerImage.src = "ChatGPT Image Dec 23, 2025 at 12_39_24 AM.png";

      function ensureAudio() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === "suspended") {
          audioCtx.resume();
        }
      }

      function playTone({ freq, duration, type, gain }) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const amp = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        amp.gain.value = gain;
        osc.connect(amp);
        amp.connect(audioCtx.destination);
        osc.start();
        amp.gain.exponentialRampToValueAtTime(
          0.001,
          audioCtx.currentTime + duration
        );
        osc.stop(audioCtx.currentTime + duration);
      }

      function startBackgroundMusic() {
        if (bgMusic.paused) {
          bgMusic.play();
        }
      }

      function stopBackgroundMusic() {
        if (!bgMusic.paused) {
          bgMusic.pause();
          bgMusic.currentTime = 0;
        }
      }

      function playJumpSound() {
        playTone({ freq: 520, duration: 0.15, type: "triangle", gain: 0.08 });
      }

      function playSnackSound() {
        playTone({ freq: 820, duration: 0.12, type: "sine", gain: 0.1 });
      }

      function playSpoiledSound() {
        playTone({ freq: 180, duration: 0.3, type: "sawtooth", gain: 0.08 });
      }

      function playLoserSound() {
        playTone({ freq: 200, duration: 0.2, type: "square", gain: 0.1 });
        playTone({ freq: 140, duration: 0.25, type: "square", gain: 0.08 });
      }

      function loop(timestamp) {
        const delta = Math.min((timestamp - lastTime) / 1000, 0.03);
        lastTime = timestamp;
        update(delta);
        draw(timestamp / 1000);
        requestAnimationFrame(loop);
      }

      window.addEventListener("keydown", (event) => {
        ensureAudio();
        startBackgroundMusic();
        if (event.key.toLowerCase() === "r" && isGameOver) {
          level = 1;
          resetPlayer();
        }
      });

      function drawCat(x, y, r, time) {
        const bodyR = r * 1.15;
        const tailWave = Math.sin(time * 5.5) * 0.6;

        ctx.save();
        ctx.translate(x, y);

        ctx.save();
        ctx.translate(bodyR * 1.05, bodyR * 0.1);
        ctx.rotate(tailWave);
        ctx.fillStyle = "#ff8f3d";
        ctx.beginPath();
        ctx.ellipse(0, 0, bodyR * 0.75, bodyR * 0.45, 0.6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#ffd7b0";
        ctx.beginPath();
        ctx.ellipse(bodyR * 0.35, -bodyR * 0.05, bodyR * 0.25, bodyR * 0.2, 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.fillStyle = "#ff8f3d";
        ctx.beginPath();
        ctx.arc(0, 0, bodyR, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#fff1e2";
        ctx.beginPath();
        ctx.ellipse(-bodyR * 0.1, bodyR * 0.2, bodyR * 0.75, bodyR * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#1c1f2a";
        ctx.beginPath();
        ctx.ellipse(-bodyR * 0.32, -bodyR * 0.05, bodyR * 0.2, bodyR * 0.24, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(bodyR * 0.32, -bodyR * 0.05, bodyR * 0.2, bodyR * 0.24, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(-bodyR * 0.36, -bodyR * 0.1, bodyR * 0.06, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(bodyR * 0.28, -bodyR * 0.1, bodyR * 0.06, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "#8a3a22";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-bodyR * 0.1, bodyR * 0.05);
        ctx.quadraticCurveTo(0, bodyR * 0.15, bodyR * 0.1, bodyR * 0.05);
        ctx.stroke();

        ctx.restore();
      }

      function drawGameOver() {
        ctx.fillStyle = "rgba(10, 20, 30, 0.45)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2 - 40;
        const overlayImage = isWin ? winnerImage : gameOverImage;
        if (overlayImage.complete && overlayImage.naturalWidth > 0) {
          const maxWidth = canvas.width * 0.45;
          const maxHeight = canvas.height * 0.45;
          const scale = Math.min(
            maxWidth / overlayImage.naturalWidth,
            maxHeight / overlayImage.naturalHeight
          );
          const drawW = overlayImage.naturalWidth * scale;
          const drawH = overlayImage.naturalHeight * scale;
          ctx.drawImage(
            overlayImage,
            centerX - drawW / 2,
            centerY - drawH / 2,
            drawW,
            drawH
          );
        } else {
          drawCryingCatFace(centerX, centerY, 70);
        }

        ctx.fillStyle = isWin ? "#2bb673" : "#ff2d2d";
        ctx.font = "700 64px 'Jersey 10', sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`Score: ${score}`, centerX, centerY + 140);
      }

      function drawCryingCatFace(x, y, size) {
        ctx.save();
        ctx.translate(x, y);

        ctx.fillStyle = "#ff8f3d";
        ctx.beginPath();
        ctx.moveTo(-size * 0.6, -size * 0.55);
        ctx.lineTo(-size * 0.15, -size * 1.05);
        ctx.lineTo(-size * 0.05, -size * 0.4);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(size * 0.6, -size * 0.55);
        ctx.lineTo(size * 0.15, -size * 1.05);
        ctx.lineTo(size * 0.05, -size * 0.4);
        ctx.closePath();
        ctx.fill();

        ctx.save();
        ctx.translate(size * 1.0, size * 0.2);
        ctx.rotate(0.4);
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.6, size * 0.32, 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.fillStyle = "#ff8f3d";
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#1c1f2a";
        ctx.beginPath();
        ctx.ellipse(-size * 0.35, -size * 0.1, size * 0.16, size * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(size * 0.35, -size * 0.1, size * 0.16, size * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "#1c1f2a";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, size * 0.2, size * 0.22, 0, Math.PI);
        ctx.stroke();

        ctx.fillStyle = "#8fd3ff";
        ctx.beginPath();
        ctx.ellipse(-size * 0.35, size * 0.25, size * 0.08, size * 0.18, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(size * 0.35, size * 0.25, size * 0.08, size * 0.18, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      requestAnimationFrame(loop);
    </script>
  </body>
</html>
